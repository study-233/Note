# DP

**动态规划（Dynamic Programming，简称 DP）** 是一种非常重要的算法设计技术，主要用于解决具有 **重叠子问题** 和 **最优子结构** 性质的问题。它的核心思想是通过将问题分解为子问题，并保存子问题的解，避免重复计算，从而提高效率。

---

### 1. **动态规划的核心思想**

动态规划的核心思想可以概括为：
1. **分解问题**：将原问题分解为若干子问题。
2. **保存子问题的解**：通过记忆化（缓存）或表格化（填表）保存子问题的解，避免重复计算。
3. **递推求解**：通过子问题的解推导出原问题的解。

---

### 2. **动态规划的适用条件**

动态规划适用于满足以下两个条件的问题：
1. **重叠子问题**：问题的子问题会被多次重复计算。
   - 例如，斐波那契数列中，计算 \( F(n) \) 需要重复计算 \( F(n-1) \) 和 \( F(n-2) \)。
2. **最优子结构**：问题的最优解可以通过子问题的最优解推导出来。
   - 例如，最短路径问题中，从 A 到 B 的最短路径可以通过从 A 到中间点 C 的最短路径和从 C 到 B 的最短路径推导出来。

---

### 3. **动态规划的两种实现方式**

动态规划有两种常见的实现方式：
1. **自顶向下（记忆化搜索）**：
   - 使用递归解决问题，同时通过缓存（如哈希表或数组）保存子问题的解。
   - 适合子问题数量较少的情况。
2. **自底向上（填表法）**：
   - 使用迭代从最小的子问题开始，逐步求解更大的子问题，直到解决原问题。
   - 适合子问题数量较多的情况。

---

### 4. **动态规划的经典问题**

#### **问题 1：斐波那契数列**
- **问题描述**：计算第 \( n \) 个斐波那契数 \( F(n) \)，其中 \( F(0) = 0 \)，\( F(1) = 1 \)，\( F(n) = F(n-1) + F(n-2) \)。
- **动态规划解法**：
  - **状态定义**：\( dp[i] \) 表示第 \( i \) 个斐波那契数。
  - **状态转移方程**：\( dp[i] = dp[i-1] + dp[i-2] \)。
  - **初始条件**：\( dp[0] = 0 \)，\( dp[1] = 1 \)。
  - **填表法代码**：
    ```python
    def fibonacci(n):
        if n == 0:
            return 0
        dp = [0] * (n + 1)
        dp[0] = 0
        dp[1] = 1
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        return dp[n]
    ```
  - **优化**：由于只需要前两个状态，可以用两个变量代替数组：
    ```python
    def fibonacci(n):
        if n == 0:
            return 0
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b
    ```

---

#### **问题 2：背包问题**
- **问题描述**：给定一组物品，每个物品有重量 \( w_i \) 和价值 \( v_i \)，以及一个容量为 \( W \) 的背包。如何选择物品放入背包，使得总价值最大？
- **动态规划解法**：
  - **状态定义**：\( dp[i][j] \) 表示前 \( i \) 个物品中，容量为 \( j \) 的背包能装的最大价值。
  - **状态转移方程**：
    $$
    dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w_i] + v_i)
    $$
    
    - 如果不选第 \( i \) 个物品：\( dp[i][j] = dp[i-1][j] \)。
    - 如果选第 \( i \) 个物品：\( dp[i][j] = dp[i-1][j-w_i] + v_i \)。
  - **初始条件**：\( dp[0][j] = 0 \)（没有物品时价值为 0）。
  - **填表法代码**：
    ```python
    def knapsack(weights, values, W):
        n = len(weights)
        dp = [[0] * (W + 1) for _ in range(n + 1)]
        for i in range(1, n + 1):
            for j in range(W + 1):
                if j >= weights[i - 1]:
                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1])
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[n][W]
    ```
  - **优化**：可以将二维数组优化为一维数组：
    ```python
    def knapsack(weights, values, W):
        n = len(weights)
        dp = [0] * (W + 1)
        for i in range(n):
            for j in range(W, weights[i] - 1, -1):
                dp[j] = max(dp[j], dp[j - weights[i]] + values[i])
        return dp[W]
    ```

---

#### **问题 3：最长公共子序列（LCS）**
- **问题描述**：给定两个字符串 \( s1 \) 和 \( s2 \)，求它们的最长公共子序列的长度。
- **动态规划解法**：
  - **状态定义**：\( dp[i][j] \) 表示 \( s1 \) 的前 \( i \) 个字符和 \( s2 \) 的前 \( j \) 个字符的最长公共子序列长度。
  - **状态转移方程**：
    $$
    dp[i][j] = 
    \begin{cases} 
    dp[i-1][j-1] + 1 & \text{if } s1[i-1] == s2[j-1] \\
    \max(dp[i-1][j], dp[i][j-1]) & \text{otherwise}
    \end{cases}
    $$
  - **初始条件**：\( dp[0][j] = 0 \)，\( dp[i][0] = 0 \)。
  - **填表法代码**：
    
    ```python
    def longest_common_subsequence(s1, s2):
        m, n = len(s1), len(s2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i - 1] == s2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        return dp[m][n]
    ```

---

### 5. **动态规划的解题步骤**

1. **定义状态**：明确问题的状态是什么，如何用变量表示。
2. **写出状态转移方程**：明确如何从子问题的解推导出当前问题的解。
3. **确定初始条件**：明确最简单的情况（边界条件）的解。
4. **选择实现方式**：自顶向下（记忆化搜索）或自底向上（填表法）。
5. **优化空间复杂度**：如果可能，将二维数组优化为一维数组。

---

### 6. **动态规划的常见优化技巧**

1. **滚动数组**：将二维数组优化为一维数组，减少空间复杂度。
2. **状态压缩**：用位运算或其他方式压缩状态。
3. **剪枝**：在搜索过程中提前排除不可能的情况。

---

### 总结

动态规划是一种强大的算法设计技术，适用于许多复杂问题。通过分解问题、保存子问题的解，并利用状态转移方程，可以高效地解决许多实际问题。如果你有具体的问题，可以告诉我，我会帮你分析如何用动态规划解决！

# **数位 DP（Digit Dynamic Programming）**

数位 DP 是一种用于解决与数字的位数相关问题的动态规划方法。它通常用于处理以下类型的问题：

- 统计某个范围内满足特定条件的数字个数。
- 计算数字的某些性质（如二进制中 1 的个数、数字的各位之和等）。

#### **数位 DP 的核心思想**：

- 将数字按位分解（例如十进制或二进制），然后逐位处理。
- 使用动态规划记录状态，避免重复计算。

#### **数位 DP 的常见步骤**：

1. **状态定义**：

   - 通常需要记录当前处理的位数、是否达到上限、以及一些额外的限制条件（如二进制中 1 的个数）。

   - 例如，

     ```
     dp[pos][limit][cnt]
     ```

      

     表示：

     - `pos`：当前处理的位数。
     - `limit`：是否达到当前位的上限（例如，数字的上限是 123，当前处理到第二位，如果第一位是 1，那么第二位的上限是 2）。
     - `cnt`：额外的状态（例如，二进制中 1 的个数）。

2. **状态转移**：

   - 根据当前位的取值范围（受 `limit` 限制），枚举当前位的可能值。
   - 更新状态（例如，如果当前位是 1，则 `cnt` 加 1）。

3. **边界条件**：

   - 当所有位处理完毕时，根据状态判断是否满足条件。

4. **记忆化**：

   - 使用记忆化搜索（递归 + 缓存）来避免重复计算。

#### **数位 DP 的代码框架**（以统计二进制中 1 的个数为例）：

```
PYTHONdef count_numbers_with_ones(K, target_ones):
    # 将 K 转换为二进制字符串
    binary_K = bin(K)[2:]  # 去掉 '0b' 前缀
    n = len(binary_K)
    
    # 记忆化缓存
    from functools import lru_cache
    
    @lru_cache(maxsize=None)
    def dfs(pos, limit, cnt):
        # 边界条件：所有位处理完毕
        if pos == n:
            return 1 if cnt == target_ones else 0
        
        # 当前位的上限
        upper = int(binary_K[pos]) if limit else 1
        total = 0
        
        # 枚举当前位的可能值
        for d in range(0, upper + 1):
            new_limit = limit and (d == upper)  # 是否达到上限
            new_cnt = cnt + (1 if d == 1 else 0)  # 更新 1 的个数
            total += dfs(pos + 1, new_limit, new_cnt)
        
        return total
    
    return dfs(0, True, 0)
```

#### **示例**：

- 统计 0 到 10 之间，二进制中 1 的个数为 2 的数字个数：

  ```
  PYTHON
  
  
  
  print(count_numbers_with_ones(10, 2))  # 输出 5
  ```

  - 解释：10 的二进制是 `1010`，符合条件的数字是 `3 (11)`、`5 (101)`、`6 (110)`、`9 (1001)`、`10 (1010)`。
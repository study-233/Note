以下是完整的实验报告，包含中文注释的代码及详细分析：

---

# 斐波那契编码生成算法实验报告

## 一、编程实验名称与内容概述  
**实验名称**：斐波那契编码生成算法  
**实验内容**：  
根据泽肯多夫定理，将输入的正整数分解为不连续的斐波那契数之和，并按照从小到大的顺序生成二进制编码，最后添加终止符"1"。  
**输入形式**：正整数  
**输出形式**：斐波那契编码字符串  

---

## 二、程序设计思路  
### 1. 实现步骤  
1. **生成斐波那契数列**：直到斐波那契数超过输入值 `n`。  
2. **找到最大斐波那契数**：确定小于等于 `n` 的最大斐波那契数的索引。  
3. **贪心选择斐波那契数**：从最大斐波那契数开始倒序选择，确保不连续。  
4. **生成编码**：根据选择结果生成二进制字符串并添加终止符。  

### 2. 数据结构与算法  
- **数据结构**：  
  - `vector<int> fib`：存储斐波那契数列。  
  - `vector<bool> selected`：标记每个斐波那契数是否被选中。  
- **算法**：  
  - **贪心算法**：每次选择最大的可能斐波那契数以满足不连续性。  
  - **线性遍历**：用于生成斐波那契数列和标记选择结果。  

---

## 三、代码说明（含中文注释）

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;

    // 步骤1：生成斐波那契数列直到超过输入值n的第一个数
    vector<int> fib;
    fib.push_back(1);  // F(1) = 1
    fib.push_back(2);  // F(2) = 2

    while (true) {
        int next = fib.back() + fib[fib.size() - 2]; // 计算下一个斐波那契数
        if (next > n) {
            break; // 当超过n时停止生成
        }
        fib.push_back(next);
    }

    // 步骤2：找到最后一个不超过n的斐波那契数的索引
    int max_index = 0;
    for (long unsigned int i = 0; i < fib.size(); ++i) {
        if (fib[i] <= n) {
            max_index = i; // 更新最大索引
        }
    }

    // 步骤3：标记选中的斐波那契数
    vector<bool> selected(max_index + 1, false); // 初始化为未选中
    int current = n; // 当前剩余值

    // 从最大斐波那契数开始倒序选择
    for (int i = max_index; i >= 0; --i) {
        if (fib[i] <= current) {
            selected[i] = true; // 标记选中
            current -= fib[i]; // 减去选中的数
        }
    }

    // 步骤4：生成二进制编码并添加终止符
    string code;
    for (int i = 0; i <= max_index; ++i) {
        code += (selected[i] ? '1' : '0'); // 选中为1，未选为0
    }
    code += '1'; // 添加终止符

    cout << code << endl;
    return 0;
}
```

---

## 四、运行结果与复杂度分析  

### 1. 运行结果示例  
- **输入19**：输出 `1001011`（分解为13+5+1）  
- **输入1**：输出 `11`  
- **输入4**：输出 `1011`  

### 2. 时间复杂度分析  
- **生成斐波那契数列**：  
  斐波那契数列增长指数级，假设第 `k` 项超过 `n`，则 `k ≈ log_φ(n)`（φ为黄金分割率 ~1.618）。时间复杂度为 **O(log n)**。  
- **选择斐波那契数**：  
  需遍历 `max_index` 次（约 `log n`），时间复杂度为 **O(log n)**。  
- **总时间复杂度**：**O(log n)**。  

### 3. 空间复杂度分析  
- **斐波那契数列存储**：需要存储 `log n` 个斐波那契数，空间复杂度为 **O(log n)**。  
- **其他变量**：`selected` 数组大小为 `max_index+1`，也是 **O(log n)**。  
- **总空间复杂度**：**O(log n)**。  

---

## 五、改进方向与心得体会  

### 1. 改进方向  
- **空间优化**：无需存储完整斐波那契数列，可直接计算最大斐波那契数后逆向分解。  
- **编码生成优化**：避免字符串拼接的高开销，可预先分配内存或用位运算。  
- **终止符处理**：可直接在生成过程中添加，减少额外操作。  

### 2. 心得体会  
- 通过此实验，深入理解了**贪心算法**在斐波那契分解中的应用，以及斐波那契数列的特性（如指数增长）。  
- 实现过程中需注意：  
  1. 斐波那契数列的起始值（F(1)=1，F(2)=2）可能导致边界条件错误。  
  2. 编码的终止符必须严格添加，否则无法保证编码唯一性。  
- 复杂度分析需要结合斐波那契数列的数学性质，例如其增长速度与对数关系。  

---

## 附：流程图（文字描述）  
```
输入n → 生成斐波那契数列 → 找最大斐波那契数索引 → 贪心选择数 → 生成二进制编码 → 添加终止符 → 输出
```